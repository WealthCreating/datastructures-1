<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Datastructures tutorial • datastructures</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">datastructures</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/datastructures.html">Tutorial</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://simon-dirmeier.net">
    <span class="fa fa fa fa-home fa-2x"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/dirmeier/datastructures">
    <span class="fa fa-github fa-2x"></span>
     
  </a>
</li>
<li>
  <a href="http://twitter.com/simon_dirmeier/">
    <span class="fa fa fa fa-twitter fa-2x"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Datastructures tutorial</h1>
                        <h4 class="author">Simon Dirmeier</h4>
            
            <h4 class="date">2018-03-23</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p><code>datastructures</code> implements various data structures that are frequently used in computer science. Among these are for example <em>Fibonacci heaps</em>, <em>stacks</em>, <em>queues</em> or <em>hashmaps</em>. Advanced data structures are essential in many computer science and statistics problems, for example graph algorithms or string analysis. The package uses <code>Boost</code> and <code>STL</code> data types and extends these to <code>R</code> with <code>Rcpp</code> modules.</p>
</div>
<div id="fibonacci-and-binomial-heaps" class="section level2">
<h2 class="hasAnchor">
<a href="#fibonacci-and-binomial-heaps" class="anchor"></a>Fibonacci and binomial heaps</h2>
<p>Fibonacci and binomial heaps are priority queue data structures using the minimum heap property. They can be represented using collections of trees or linked lists consisting of <em>nodes</em> of elements. Every node is a pair of keys and values, where the key decides the priority of the <em>node</em> in the heap. Fibonacci heaps have various applications, one of the most famous being in efficiently finding shortest paths using Dijkstra’s algorithm. Fibonacci heaps can add values in amortized <span class="math inline">\(\mathcal{O}(1)\)</span> time and remove the minimum value in <span class="math inline">\(\mathcal{O}(log \, n)\)</span> time making them a good choice in many real world scenarios. Binomial heaps have in general slightly worse asymptotic bounds. However, removing the minimum element (<code>pop</code>) has an asymptotically tight bound of <span class="math inline">\(\Theta(log \, n)\)</span>. The two classes have the exact same methods, so every method explained here is available for the other class, too.</p>
<p>You can create a heap like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  fheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/fibonacci_heap.html">fibonacci_heap</a></span>(<span class="st">"numeric"</span>, <span class="st">"character"</span>)
  bheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/binomial_heap.html">binomial_heap</a></span>(<span class="st">"numeric"</span>, <span class="st">"character"</span>)</code></pre></div>
<p>This gives us heaps with <code>numeric</code> keys and <code>character</code> values. You can pick from either <code>integer</code>, <code>numeric</code> or <code>character</code> keys and values. So if we insert several key-value pairs, the pair with the <em>minimum</em> key would have the highest <em>priority</em>. Let’s insert some values and have a look:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  keys   &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">by=</span>.<span class="dv">2</span>))
  values &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">"V"</span>, keys)
  fheap  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(fheap, keys, values)

  <span class="kw"><a href="../reference/size-methods.html">size</a></span>(fheap)</code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>There are also some other ways to insert into a heap. If you want to insert a <code>vector</code>ial value, do this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  fheap  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(fheap, <span class="op">-</span><span class="dv">1</span>, letters)
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-1`
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q"
## [18] "r" "s" "t" "u" "v" "w" "x" "y" "z"</code></pre>
<p>If you want to add multiple values, you need to use a <code>vector</code>ial key and a <code>matrix</code> as value:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  fheap  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(fheap, <span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>), <span class="kw">matrix</span>(letters, <span class="dv">2</span>))
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-3`
##  [1] "b" "d" "f" "h" "j" "l" "n" "p" "r" "t" "v" "x" "z"</code></pre>
<p>Furthermore, you can use lists as values to insert into a heap:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  fheap  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(fheap, <span class="kw">c</span>(<span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">6</span>), <span class="kw">list</span>(<span class="st">"a"</span>, letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], <span class="st">"hello"</span>))
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-6`
## [1] "hello"</code></pre>
<p>Since Fibonacci and binomial heaps use the minimum heap property the first element in the heap should be <code>0 -&gt; V0</code> even though we inserted the pairs in a random fashion.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-6`
## [1] "hello"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/size-methods.html">size</a></span>(fheap)</code></pre></div>
<pre><code>## [1] 12</code></pre>
<p>That worked nicely. <code>peek</code> gives us the first element from the heap <em>without removing it</em>. If we want to have it removed we call the <code>pop</code> function. Of course this changes the priority of the heap:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/pop-methods.html">pop</a></span>(fheap)</code></pre></div>
<pre><code>## $`-6`
## [1] "hello"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/size-methods.html">size</a></span>(fheap)</code></pre></div>
<pre><code>## [1] 11</code></pre>
<p>You can alternatively insert values like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  fheap[<span class="op">-</span><span class="dv">10</span>] &lt;-<span class="st"> "V-1"</span>
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-10`
## [1] "V-1"</code></pre>
<p>This works for all the described <code>insert</code> methods above. Even though we usually don’t need to retrieve all values from a heap, you can do so using the <code>values</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/values-methods.html">values</a></span>(fheap)</code></pre></div>
<pre><code>## [[1]]
## [1] "V-1"
## 
## [[2]]
## [1] "V0.2"
## 
## [[3]]
## [1] "a"
## 
## [[4]]
## [1] "V0"
## 
## [[5]]
##  [1] "b" "d" "f" "h" "j" "l" "n" "p" "r" "t" "v" "x" "z"
## 
## [[6]]
## [1] "V1"
## 
## [[7]]
##  [1] "a" "c" "e" "g" "i" "k" "m" "o" "q" "s" "u" "w" "y"
## 
## [[8]]
## [1] "a" "b" "c" "d"
## 
## [[9]]
## [1] "V0.6"
## 
## [[10]]
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q"
## [18] "r" "s" "t" "u" "v" "w" "x" "y" "z"
## 
## [[11]]
## [1] "V0.8"
## 
## [[12]]
## [1] "V0.4"</code></pre>
<p>Sometimes, we want to decrease a key and rearrange its position in the heap. If we have a <em>unique</em> key this can be easily done:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/decrease_key-methods.html">decrease_key</a></span>(fheap, <span class="dt">from=</span><span class="op">-</span><span class="dv">10</span>, <span class="dt">to=</span><span class="op">-</span><span class="dv">11</span>)
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-11`
## [1] "V-1"</code></pre>
<p>The function takes vectors, so you can also pass vectorial <code>to</code> and <code>from</code> arguments:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/decrease_key-methods.html">decrease_key</a></span>(fheap, <span class="dt">from=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">4</span>), <span class="dt">to=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">15</span>, <span class="op">-</span><span class="dv">15</span>))
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-15`
## [1] "a" "b" "c" "d"</code></pre>
<p>However, things get more complicated if we have multiple identical keys and want to decrease a specific one. In this case, in order to decrease to correct node, we need to get its <code>handle</code> first:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/handle-methods.html">handle</a></span>(fheap, <span class="op">-</span><span class="dv">15</span>)</code></pre></div>
<pre><code>## [[1]]
## [[1]]$handle
## [1] "handle-10"
## 
## [[1]]$value
## [1] "a" "b" "c" "d"
## 
## 
## [[2]]
## [[2]]$handle
## [1] "handle-9"
## 
## [[2]]$value
## [1] "a"</code></pre>
<p>The <code>handle</code> method returns the <code>id</code> of the node and the <code>value</code> that is stored for a given <code>key</code> (in this case -15). Thus if we want to decrease a node with ambiguous key, we also need to specify the handle (e.g. the <code>id</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  hand &lt;-<span class="st"> </span><span class="kw"><a href="../reference/handle-methods.html">handle</a></span>(fheap, <span class="op">-</span><span class="dv">15</span>)  
  <span class="kw"><a href="../reference/decrease_key-methods.html">decrease_key</a></span>(fheap, <span class="op">-</span><span class="dv">15</span>, <span class="op">-</span><span class="dv">20</span>, hand[[<span class="dv">1</span>]]<span class="op">$</span>handle)
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-20`
## [1] "a" "b" "c" "d"</code></pre>
<p>The <code>handle</code> method always returns a list where every element represents a node in the heap. Every list element is again a list consisting of the node’s handle (its id). So you need to check the node’s value to figure out the corresponding handle. Furthermore, if you want to query by a node’s <code>value</code> you would call the <code>handle</code> method like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  fheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(fheap, <span class="dv">10</span>, <span class="st">"V-10"</span>)
  fheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(fheap, <span class="dv">10</span>, <span class="st">"V-10"</span>)
  h &lt;-<span class="st"> </span><span class="kw"><a href="../reference/handle-methods.html">handle</a></span>(fheap, <span class="dt">value=</span><span class="st">"V-10"</span>)
  h</code></pre></div>
<pre><code>## [[1]]
## [[1]]$handle
## [1] "handle-13"
## 
## [[1]]$key
## [1] 10
## 
## 
## [[2]]
## [[2]]$handle
## [1] "handle-14"
## 
## [[2]]$key
## [1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/decrease_key-methods.html">decrease_key</a></span>(fheap, <span class="dv">10</span>, <span class="op">-</span><span class="dv">100</span>, h[[<span class="dv">1</span>]]<span class="op">$</span>handle)
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(fheap)</code></pre></div>
<pre><code>## $`-100`
## [1] "V-10"</code></pre>
<p>In all of these scenarios neither the key nor the value need to be unique, because the handle (node id) always is.</p>
<div id="use-case" class="section level3">
<h3 class="hasAnchor">
<a href="#use-case" class="anchor"></a>Use case</h3>
<p>As a last example, consider this use case:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">library</span>(<span class="st">'purrr'</span>)
  bheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/binomial_heap.html">binomial_heap</a></span>(<span class="st">"character"</span>, <span class="st">"integer"</span>)
  bheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(bheap, letters[<span class="kw">c</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">5</span>)], <span class="kw">c</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">6</span>, 5L, 7L))
  bheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(bheap, <span class="st">"x"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
  bheap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(bheap, <span class="st">"z"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(bheap)</code></pre></div>
<pre><code>## $b
## [1] 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  vector.keys &lt;-<span class="st"> </span><span class="kw"><a href="../reference/handle-methods.html">handle</a></span>(bheap, <span class="dt">value =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>) <span class="op">%&gt;%</span>
<span class="st">    </span>purrr<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/purrr/topics/map">map_chr</a></span>(<span class="dt">.f =</span> <span class="cf">function</span>(x) x<span class="op">$</span>key)
  vector.keys</code></pre></div>
<pre><code>## [1] "x" "z"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/decrease_key-methods.html">decrease_key</a></span>(bheap, <span class="dt">from=</span>vector.keys, <span class="dt">to=</span><span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>))
  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(bheap)</code></pre></div>
<pre><code>## $a
## [1] 1 2 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  hand &lt;-<span class="st"> </span><span class="kw"><a href="../reference/handle-methods.html">handle</a></span>(bheap, <span class="dt">key =</span> <span class="st">"b"</span>)
  hand</code></pre></div>
<pre><code>## [[1]]
## [[1]]$handle
## [1] "handle-0"
## 
## [[1]]$value
## [1] 2
## 
## 
## [[2]]
## [[2]]$handle
## [1] "handle-8"
## 
## [[2]]$value
## [1] 1 2 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/decrease_key-methods.html">decrease_key</a></span>(bheap, <span class="dt">from=</span><span class="st">"b"</span>, <span class="dt">to=</span><span class="st">"a"</span>, <span class="dt">handle=</span>hand[[<span class="dv">2</span>]]<span class="op">$</span>handle)
  <span class="kw"><a href="../reference/pop-methods.html">pop</a></span>(bheap)</code></pre></div>
<pre><code>## $a
## [1] 1 2 3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/pop-methods.html">pop</a></span>(bheap)</code></pre></div>
<pre><code>## $a
## [1] 1 2 3</code></pre>
</div>
</div>
<div id="hashmaps-bimaps-and-multimaps" class="section level2">
<h2 class="hasAnchor">
<a href="#hashmaps-bimaps-and-multimaps" class="anchor"></a>Hashmaps, bimaps and multimaps</h2>
<p>Maps use hash functions to store key-value pairs. Given a key, the hash function computes a <em>bucket</em> where the value is stored, making lookup, insertion and deletion on average possible in <span class="math inline">\(\mathcal{O}(1)\)</span> time. In the worst case these runtimes decrease to <span class="math inline">\(\mathcal{O}(n)\)</span> time, where <span class="math inline">\(n\)</span> is the number of entries in a bucket. The difference between the three classes is that hashmaps and multimaps compute a mapping from keys to values (the hash function) <span class="math display">\[ \, f: \mathcal{K} \rightarrow \mathcal{V} \, \]</span> in <strong>‘one direction’</strong>, while bimaps also compute a mapping <span class="math display">\[ \, f: \mathcal{V} \rightarrow \mathcal{K} \, \]</span> in the <strong>‘other direction’</strong>. So a bimap is essentially a combination of two hashmaps. The difference between a hashmap and a multimap is that for hashs only <em>one</em> unique key can be stored for a value, while multimaps allow storing the same key several times fur multiple values,</p>
<p>Maps can get created like this, this time we use <code>&lt;character, integer&gt;</code> pairs:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  hash  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/hashmap.html">hashmap</a></span>(<span class="st">"character"</span>, <span class="st">"integer"</span>)
  bimap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/bimap.html">bimap</a></span>(<span class="st">"character"</span>, <span class="st">"integer"</span>)
  mm    &lt;-<span class="st"> </span><span class="kw"><a href="../reference/multimap.html">multimap</a></span>(<span class="st">"character"</span>, <span class="st">"integer"</span>)</code></pre></div>
<p>Insertion to maps works just like before, by calling the <code>insert</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  keys   &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">"V"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)
  values &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
  hash   &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(hash, keys[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], values[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>])
  bimap  &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(bimap, keys[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], values[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>])
  mm     &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(mm, keys[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], values[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>])
  hash[keys[<span class="dv">5</span>]]  &lt;-<span class="st"> </span>values[<span class="dv">5</span>]
  bimap[keys[<span class="dv">5</span>]] &lt;-<span class="st"> </span>values[<span class="dv">5</span>]
  mm[keys[<span class="dv">5</span>]]    &lt;-<span class="st"> </span>values[<span class="dv">5</span>]
  mm[keys[<span class="dv">5</span>]]    &lt;-<span class="st"> </span>values[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</code></pre></div>
<p>Values (and keys in the case of bimaps) can then be accessed like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/get-methods.html">get</a></span>(hash, keys[<span class="dv">1</span>])</code></pre></div>
<pre><code>## [[1]]
## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  hash[keys[<span class="dv">1</span>]]</code></pre></div>
<pre><code>## [[1]]
## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/get-methods.html">get</a></span>(bimap, keys[<span class="dv">1</span>], <span class="st">"values"</span>)</code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/get-methods.html">get</a></span>(bimap, values[<span class="dv">2</span>], <span class="st">"keys"</span>)</code></pre></div>
<pre><code>## [1] "V2"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/get-methods.html">get</a></span>(bimap, keys[<span class="dv">1</span>])</code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/get-methods.html">get</a></span>(mm, keys[<span class="dv">5</span>])</code></pre></div>
<pre><code>## [[1]]
## [1] 5
## 
## [[2]]
## [1] 1 2 3 4 5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  mm[keys[<span class="dv">5</span>]]</code></pre></div>
<pre><code>## [[1]]
## [1] 5
## 
## [[2]]
## [1] 1 2 3 4 5</code></pre>
<p>For hashmapsthe subset-operator <code>[</code> is also supported for accessing elements. This does not make so much sense for bimaps, because here we have to choose whether we want to access keys or values. In the example on the top we showed how both is possible by either providing <code>keys</code> or <code>values</code> as third argument to the <code>get</code> function. If you leave it out, then the third argument defaults to <code>values</code>.</p>
<p>If you want to directly access <code>keys</code> or <code>values</code> as vectors or have a look at a few random elements, you would call:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/keys-methods.html">keys</a></span>(bimap)</code></pre></div>
<pre><code>## [1] "V1" "V2" "V3" "V4" "V5"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/values-methods.html">values</a></span>(hash)</code></pre></div>
<pre><code>## [[1]]
## [1] 5
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 2
## 
## [[4]]
## [1] 3
## 
## [[5]]
## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/head-methods.html">head</a></span>(bimap)</code></pre></div>
<pre><code>## $V1
## [1] 1
## 
## $V2
## [1] 2
## 
## $V3
## [1] 3
## 
## $V4
## [1] 4
## 
## $V5
## [1] 5</code></pre>
</div>
<div id="queues-and-stacks" class="section level2">
<h2 class="hasAnchor">
<a href="#queues-and-stacks" class="anchor"></a>Queues and stacks</h2>
<p>Queues and stackes are two list datastructures using the <code>STL</code>’s <code>std::deque</code> in the backend, i.e. insertion at the end and getting the first element can be done in constant time <span class="math inline">\(\mathcal{O}(1)\)</span> . Queues and stacks are for example used in <em>depths-first-search</em> and <em>breadth-first-search</em> making them versatile datastructures. While queues use the <em>first-in-first-out</em> principle, stacks use the <em>last-in-first-out</em> principle.</p>
<p>The two datatypes use the exact same methods. You can instantiate a stack or a queue using:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  qu &lt;-<span class="st"> </span><span class="kw"><a href="../reference/queue.html">queue</a></span>(<span class="st">"numeric"</span>)
  st &lt;-<span class="st"> </span><span class="kw"><a href="../reference/stack.html">stack</a></span>(<span class="st">"numeric"</span>)</code></pre></div>
<p>As before, you can pick either <code>numeric</code>, <code>integer</code> or <code>character</code> keys. Now, let’s again insert some data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  keys &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">by=</span>.<span class="dv">2</span>)
  <span class="kw">print</span>(keys)</code></pre></div>
<pre><code>## [1] 0.0 0.2 0.4 0.6 0.8 1.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  qu &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(qu, keys)
  st &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(st, keys)</code></pre></div>
<p><strong>BEWARE:</strong> If you add <em>one</em> <code>vector</code> to queues and stacks it will add <em>one</em> element:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(qu)</code></pre></div>
<pre><code>## [1] 0.0 0.2 0.4 0.6 0.8 1.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/peek-methods.html">peek</a></span>(st)</code></pre></div>
<pre><code>## [1] 0.0 0.2 0.4 0.6 0.8 1.0</code></pre>
<p>If you want to add <em>multiple</em> elements, you need to add a list:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  st &lt;-<span class="st"> </span><span class="kw"><a href="../reference/insert-methods.html">insert</a></span>(st, <span class="kw">list</span>(<span class="dv">1</span>, <span class="kw">rnorm</span>(<span class="dv">5</span>)))
  <span class="kw"><a href="../reference/pop-methods.html">pop</a></span>(st)</code></pre></div>
<pre><code>## [1] -1.287195099 -1.860345985 -0.009468223  1.330000853 -0.352145774</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/pop-methods.html">pop</a></span>(st)</code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>The <code>pop</code> operation removed the <em>head</em> element from the data structure.</p>
<p>For a <code>queue</code> <code>pop</code> and <code>peek</code> return the <em>first</em> element that got inserted, while a stack returns the <em>last</em> element that was inserted.</p>
</div>
<div id="author" class="section level2">
<h2 class="hasAnchor">
<a href="#author" class="anchor"></a>Author</h2>
<ul>
<li>Simon Dirmeier <a href="mailto:simon.dirmeier@web.de">simon.dirmeier@web.de</a>
</li>
</ul>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#fibonacci-and-binomial-heaps">Fibonacci and binomial heaps</a></li>
      <li><a href="#hashmaps-bimaps-and-multimaps">Hashmaps, bimaps and multimaps</a></li>
      <li><a href="#queues-and-stacks">Queues and stacks</a></li>
      <li><a href="#author">Author</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by <a href="http://www.simon-dirmeier.net">Simon Dirmeier</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
